{
  "name": "Flow 1 - Quick Progress Forecast",
  "nodes": [
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 1
            }
          ]
        }
      },
      "name": "Cron Trigger (Every 1 minute)",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1,
      "position": [240, 300]
    },
    {
      "parameters": {
        "url": "={{$env.BACKEND_API_URL}}/api/webhooks/n8n/projects",
        "authentication": "none",
        "options": {}
      },
      "name": "HTTP: Get Projects",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [460, 300]
    },
    {
      "parameters": {
        "url": "={{$env.BACKEND_API_URL}}/api/webhooks/n8n/tasks",
        "authentication": "none",
        "options": {}
      },
      "name": "HTTP: Get Tasks",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [680, 300]
    },
    {
      "parameters": {
        "functionCode": "// Prepare prompt for Gemini AI\n// Analyze both in_progress AND todo tasks that haven't been completed\nconst response = $input.first().json;\nconst tasks = response.tasks || [];\nconst taskData = [];\n\nfor (const t of tasks) {\n  // Skip completed tasks only\n  if (t.status === 'done') continue;\n  \n  taskData.push({\n    id: t.id,\n    name: t.name,\n    progress: t.progress || 0,\n    deadline: t.deadline,\n    status: t.status,\n    priority: t.priority,\n    owner_id: t.owner_id,\n    project_name: t.project_name,\n    owner_name: t.owner_name\n  });\n}\n\nif (taskData.length === 0) {\n  // Return a special marker to indicate no tasks to process\n  return [{\n    json: {\n      skip: true,\n      message: 'No pending tasks to analyze'\n    }\n  }];\n}\n\nconst today = new Date().toISOString().split('T')[0];\n\nconst prompt = 'B·∫°n l√† chuy√™n gia qu·∫£n l√Ω deadline C√Å NH√ÇN. Ph√¢n t√≠ch c√°c task sau v√† d·ª± ƒëo√°n nguy c∆° tr·ªÖ deadline.\\nH√¥m nay l√†: ' + today + '\\n\\nDanh s√°ch tasks c·∫ßn ph√¢n t√≠ch:\\n' + JSON.stringify(taskData, null, 2) + '\\n\\nV·ªõi M·ªñI task trong danh s√°ch tr√™n, ƒë√°nh gi√°:\\n- task_id: ID c·ªßa task (s·ªë nguy√™n, b·∫Øt bu·ªôc)\\n- risk_level: \"low\", \"medium\", \"high\", ho·∫∑c \"critical\" (b·∫Øt bu·ªôc)\\n- risk_percentage: 0-100 (s·ªë th·ª±c, b·∫Øt bu·ªôc)\\n- predicted_delay_days: s·ªë ng√†y d·ª± ƒëo√°n tr·ªÖ, 0 n·∫øu kh√¥ng tr·ªÖ (s·ªë nguy√™n)\\n- analysis: ph√¢n t√≠ch ng·∫Øn g·ªçn b·∫±ng ti·∫øng Vi·ªát (string)\\n- recommendations: khuy·∫øn ngh·ªã c·ª• th·ªÉ b·∫±ng ti·∫øng Vi·ªát (string)\\n\\nQUY T·∫ÆC QUAN TR·ªåNG:\\n1. Ph√¢n t√≠ch D·ª∞A TR√äN deadline v√† progress hi·ªán t·∫°i\\n2. N·∫øu progress < 50% v√† deadline c√≤n < 7 ng√†y => high/critical risk\\n3. N·∫øu progress = 0% v√† deadline ƒë√£ qua => critical risk, 100%\\n4. T·∫•t c·∫£ ' + taskData.length + ' task PH·∫¢I c√≥ trong k·∫øt qu·∫£\\n\\nTr·∫£ v·ªÅ ƒê√öNG ƒê·ªäNH D·∫†NG JSON ARRAY sau (KH√îNG c√≥ markdown, KH√îNG c√≥ gi·∫£i th√≠ch th√™m):\\n[{\"task_id\": 1, \"risk_level\": \"high\", \"risk_percentage\": 75.5, \"predicted_delay_days\": 3, \"analysis\": \"Ph√¢n t√≠ch...\", \"recommendations\": \"Khuy·∫øn ngh·ªã...\"}]';\n\nreturn [{\n  json: {\n    skip: false,\n    prompt: prompt,\n    taskData: taskData\n  }\n}];"
      },
      "name": "Function: Prepare AI Prompt",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [900, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.skip}}",
              "value2": false
            }
          ]
        }
      },
      "name": "IF: Has Tasks",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "url": "=https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={{$env.GEMINI_API_KEY}}",
        "authentication": "none",
        "method": "POST",
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={\n  \"contents\": [\n    {\n      \"parts\": [\n        {\n          \"text\": {{JSON.stringify($json.prompt)}}\n        }\n      ]\n    }\n  ],\n  \"generationConfig\": {\n    \"responseMimeType\": \"application/json\"\n  }\n}",
        "options": {
          "retry": {
            "values": {
              "maxTries": 3,
              "retryOnStatusCodes": {
                "values": [
                  {
                    "statusCode": "429,500,502,503,504"
                  }
                ]
              },
              "waitBetweenTries": 2000
            }
          },
          "timeout": 60000
        }
      },
      "name": "HTTP: Gemini API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1320, 200]
    },
    {
      "parameters": {
        "functionCode": "// Parse AI response and extract JSON\nconst response = $input.first().json;\nconst taskData = $node['IF: Has Tasks'].json.taskData || [];\nlet results = [];\n\ntry {\n  // Check if we have a valid AI response\n  if (!response.candidates || !response.candidates[0] || !response.candidates[0].content) {\n    throw new Error('Invalid AI response structure');\n  }\n  \n  const text = response.candidates[0].content.parts[0].text;\n  let jsonStr = text;\n  \n  // Remove markdown code blocks if present\n  const codeBlockMatch = text.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n  if (codeBlockMatch) {\n    jsonStr = codeBlockMatch[1].trim();\n  }\n  \n  // Try to extract JSON array\n  const jsonMatch = jsonStr.match(/\\[\\s*\\{[\\s\\S]*\\}\\s*\\]/s);\n  if (jsonMatch) {\n    results = JSON.parse(jsonMatch[0]);\n  } else {\n    results = JSON.parse(jsonStr);\n  }\n  \n  // Validate and ensure all required fields exist\n  results = results.map(r => {\n    const taskInfo = taskData.find(t => t.id === r.task_id) || {};\n    return {\n      task_id: r.task_id,\n      task_name: taskInfo.name || '',\n      task_progress: taskInfo.progress || 0,\n      task_deadline: taskInfo.deadline || '',\n      project_name: taskInfo.project_name || '',\n      owner_id: taskInfo.owner_id || null,\n      owner_name: taskInfo.owner_name || '',\n      risk_level: (r.risk_level || 'medium').toLowerCase(),\n      risk_percentage: parseFloat(r.risk_percentage) || 50.0,\n      predicted_delay_days: parseInt(r.predicted_delay_days) || 0,\n      analysis: r.analysis || 'Kh√¥ng c√≥ ph√¢n t√≠ch chi ti·∫øt',\n      recommendations: r.recommendations || 'C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô th∆∞·ªùng xuy√™n'\n    };\n  });\n  \n} catch (error) {\n  console.log('Error parsing AI response:', error.message);\n  console.log('Response:', JSON.stringify(response).substring(0, 500));\n  \n  // Fallback: Create basic forecasts for all tasks if AI fails\n  if (taskData.length > 0) {\n    const now = new Date();\n    results = taskData.map(task => {\n      const progress = task.progress || 0;\n      const deadline = task.deadline ? new Date(task.deadline) : null;\n      const daysUntilDeadline = deadline ? Math.ceil((deadline - now) / (1000 * 60 * 60 * 24)) : 30;\n      \n      let riskLevel = 'low';\n      let riskPercentage = 20;\n      let predictedDelay = 0;\n      \n      // Calculate risk based on progress and deadline\n      if (daysUntilDeadline < 0) {\n        // Already overdue\n        riskLevel = 'critical';\n        riskPercentage = 100;\n        predictedDelay = Math.abs(daysUntilDeadline);\n      } else if (progress < 30 && daysUntilDeadline < 7) {\n        riskLevel = 'critical';\n        riskPercentage = 90;\n        predictedDelay = Math.max(0, 7 - daysUntilDeadline);\n      } else if (progress < 50 && daysUntilDeadline < 7) {\n        riskLevel = 'high';\n        riskPercentage = 75;\n        predictedDelay = Math.max(0, 3 - daysUntilDeadline + 3);\n      } else if (progress < 30) {\n        riskLevel = 'high';\n        riskPercentage = 70;\n        predictedDelay = 3;\n      } else if (progress < 60) {\n        riskLevel = 'medium';\n        riskPercentage = 50;\n        predictedDelay = 1;\n      }\n      \n      return {\n        task_id: task.id,\n        task_name: task.name || '',\n        task_progress: task.progress || 0,\n        task_deadline: task.deadline || '',\n        project_name: task.project_name || '',\n        owner_id: task.owner_id || null,\n        owner_name: task.owner_name || '',\n        risk_level: riskLevel,\n        risk_percentage: riskPercentage,\n        predicted_delay_days: predictedDelay,\n        analysis: 'Task \"' + task.name + '\" ƒëang ·ªü ' + progress + '% ti·∫øn ƒë·ªô. ' + (daysUntilDeadline < 0 ? 'ƒê√£ qu√° h·∫°n ' + Math.abs(daysUntilDeadline) + ' ng√†y!' : 'C√≤n ' + daysUntilDeadline + ' ng√†y ƒë·∫øn deadline.'),\n        recommendations: progress < 50 ? 'C·∫ßn t·∫≠p trung ho√†n th√†nh task n√†y ngay.' : 'C·∫≠p nh·∫≠t ti·∫øn ƒë·ªô th∆∞·ªùng xuy√™n ƒë·ªÉ AI ƒë√°nh gi√° ch√≠nh x√°c h∆°n.'\n      };\n    });\n  }\n}\n\nconst validResults = results.filter(r => r.task_id && r.risk_level);\n\nif (validResults.length === 0) {\n  // Return empty marker instead of empty array\n  return [{ json: { empty: true } }];\n}\n\nreturn validResults.map(r => ({ json: r }));"
      },
      "name": "Function: Parse AI Response",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [1540, 200]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{$json.empty}}",
              "value2": true
            }
          ]
        }
      },
      "name": "IF: Has Results",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [1760, 200]
    },
    {
      "parameters": {
        "url": "={{$env.BACKEND_API_URL}}/api/webhooks/n8n/forecast-complete",
        "authentication": "none",
        "method": "POST",
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={\n  \"task_id\": {{$json.task_id}},\n  \"risk_level\": {{JSON.stringify($json.risk_level)}},\n  \"risk_percentage\": {{$json.risk_percentage}},\n  \"predicted_delay_days\": {{$json.predicted_delay_days || 0}},\n  \"ai_analysis\": {{JSON.stringify($json.analysis || \"Kh√¥ng c√≥ ph√¢n t√≠ch\")}},\n  \"recommendations\": {{JSON.stringify($json.recommendations || \"Kh√¥ng c√≥ khuy·∫øn ngh·ªã\")}}\n}",
        "options": {}
      },
      "name": "HTTP: Save Forecast",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [1980, 100]
    },
    {
      "parameters": {
        "functionCode": "// Preserve original data after HTTP Save Forecast\n// Get the data from the previous parse step\nconst items = $input.all();\nconst parseNode = $node['IF: Has Results'];\n\nreturn items.map((item, index) => {\n  // Try to get original data from parse response\n  const originalData = parseNode.json || item.json;\n  return {\n    json: originalData\n  };\n});"
      },
      "name": "Function: Restore Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2200, 100]
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{$json.risk_percentage}}",
              "operation": "larger",
              "value2": 70
            }
          ]
        }
      },
      "name": "IF: High Risk Detected",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2420, 100]
    },
    {
      "parameters": {
        "url": "={{$env.BACKEND_API_URL}}/api/webhooks/n8n/task-owner-email/{{$json.task_id}}",
        "authentication": "none",
        "options": {}
      },
      "name": "HTTP: Get Task Owner Email",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [2640, 100]
    },
    {
      "parameters": {
        "functionCode": "// L·∫•y email c·ªßa project owner (ch·ªß s·ªü h·ªØu task)\nconst taskInfo = $input.first().json;\nconst riskData = $node['IF: High Risk Detected'].json;\n\nconst recipientEmail = taskInfo.owner_email;\nconst recipientName = taskInfo.owner_name || 'User';\n\nreturn {\n  json: {\n    recipientEmail: recipientEmail,\n    recipientName: recipientName,\n    taskId: riskData.task_id,\n    taskName: riskData.task_name || taskInfo.task_name,\n    taskProgress: riskData.task_progress || taskInfo.task_progress || 0,\n    taskDeadline: riskData.task_deadline || taskInfo.task_deadline,\n    projectName: riskData.project_name || taskInfo.project_name,\n    riskLevel: riskData.risk_level,\n    riskPercentage: riskData.risk_percentage,\n    predictedDelay: riskData.predicted_delay_days,\n    analysis: riskData.analysis,\n    recommendations: riskData.recommendations\n  }\n};"
      },
      "name": "Function: Prepare Email Data",
      "type": "n8n-nodes-base.function",
      "typeVersion": 1,
      "position": [2860, 100]
    },
    {
      "parameters": {
        "fromEmail": "={{$env.EMAIL_FROM}}",
        "toEmail": "={{$json.recipientEmail}}",
        "subject": "‚ö†Ô∏è C·∫£nh b√°o: Task c·ªßa b·∫°n c√≥ nguy c∆° tr·ªÖ cao",
        "emailType": "html",
        "text": "=Xin ch√†o {{$json.recipientName}},\n\nH·ªá th·ªëng AI ph√°t hi·ªán task c·ªßa b·∫°n c√≥ nguy c∆° tr·ªÖ deadline cao.\n\nüìã Task c·ªßa b·∫°n:\n- T√™n task: {{$json.taskName}}\n- D·ª± √°n: {{$json.projectName}}\n- Task ID: #{{$json.taskId}}\n- Ti·∫øn ƒë·ªô hi·ªán t·∫°i: {{$json.taskProgress}}%\n- Deadline: {{$json.taskDeadline}}\n\nüö® M·ª©c ƒë·ªô r·ªßi ro:\n- Risk Level: {{$json.riskLevel}}\n- Risk Percentage: {{$json.riskPercentage}}%\n- D·ª± ƒëo√°n tr·ªÖ: {{$json.predictedDelay}} ng√†y\n\nü§ñ Ph√¢n t√≠ch AI:\n{{$json.analysis}}\n\nüí° Khuy·∫øn ngh·ªã:\n{{$json.recommendations}}\n\nC·∫≠p nh·∫≠t Task ngay: http://localhost:5173/tasks",
        "html": "=<html><head><style>body{font-family:Arial,sans-serif;line-height:1.6;color:#333}.container{max-width:600px;margin:0 auto;padding:20px;background:#f9f9f9}.header{background:#dc2626;color:white;padding:20px;text-align:center;border-radius:5px 5px 0 0}.content{background:white;padding:30px;border-radius:0 0 5px 5px}.alert-box{background:#fee;border-left:4px solid #dc2626;padding:15px;margin:15px 0}.info-box{background:#f0f9ff;border-left:4px solid #0ea5e9;padding:15px;margin:15px 0}</style></head><body><div class='container'><div class='header'><h2>‚ö†Ô∏è C·∫¢NH B√ÅO NGUY C∆† TR·ªÑ DEADLINE</h2></div><div class='content'><p>Xin ch√†o <strong>{{$json.recipientName}}</strong>,</p><p>H·ªá th·ªëng AI ph√°t hi·ªán <strong>task c·ªßa b·∫°n</strong> c√≥ nguy c∆° tr·ªÖ deadline cao.</p><div class='alert-box'><h3>üìã Task c·ªßa b·∫°n</h3><ul><li><strong>T√™n task:</strong> {{$json.taskName}}</li><li><strong>D·ª± √°n:</strong> {{$json.projectName}}</li><li><strong>Task ID:</strong> #{{$json.taskId}}</li><li><strong>Ti·∫øn ƒë·ªô hi·ªán t·∫°i:</strong> {{$json.taskProgress}}%</li><li><strong>Deadline:</strong> {{$json.taskDeadline}}</li></ul></div><div class='alert-box'><h3>üö® M·ª©c ƒë·ªô r·ªßi ro</h3><ul><li><strong>Risk Level:</strong> {{$json.riskLevel}}</li><li><strong>Risk Percentage:</strong> {{$json.riskPercentage}}%</li><li><strong>D·ª± ƒëo√°n tr·ªÖ:</strong> {{$json.predictedDelay}} ng√†y</li></ul></div><div class='info-box'><h3>ü§ñ Ph√¢n t√≠ch AI</h3><p>{{$json.analysis}}</p></div><div class='info-box'><h3>üí° Khuy·∫øn ngh·ªã</h3><p>{{$json.recommendations}}</p></div><p style='margin-top:30px'><a href='http://localhost:5173/tasks' style='display:inline-block;background:#0ea5e9;color:white;padding:12px 30px;text-decoration:none;border-radius:5px'>C·∫≠p nh·∫≠t Task ngay</a></p></div></div></body></html>",
        "options": {}
      },
      "name": "Send Email: Alert to Owner",
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2,
      "position": [3080, 100],
      "credentials": {
        "smtp": {
          "id": "1",
          "name": "SMTP Account"
        }
      }
    },
    {
      "parameters": {
        "url": "={{$env.BACKEND_API_URL}}/api/webhooks/n8n/automation-log",
        "authentication": "none",
        "method": "POST",
        "sendBody": true,
        "contentType": "json",
        "specifyBody": "json",
        "jsonBody": "={\n  \"workflow_name\": \"Quick Progress Forecast\",\n  \"status\": \"success\",\n  \"input_data\": {\"message\": \"Email alert sent\"},\n  \"output_data\": {\"task_id\": {{$node['Function: Prepare Email Data'].json.taskId || 0}}, \"risk_level\": {{JSON.stringify($node['Function: Prepare Email Data'].json.riskLevel || 'unknown')}}}\n}",
        "options": {}
      },
      "name": "HTTP: Log Success",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [3300, 100]
    }
  ],
  "connections": {
    "Cron Trigger (Every 1 minute)": {
      "main": [
        [
          {
            "node": "HTTP: Get Projects",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP: Get Projects": {
      "main": [
        [
          {
            "node": "HTTP: Get Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP: Get Tasks": {
      "main": [
        [
          {
            "node": "Function: Prepare AI Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Function: Prepare AI Prompt": {
      "main": [
        [
          {
            "node": "IF: Has Tasks",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF: Has Tasks": {
      "main": [
        [
          {
            "node": "HTTP: Gemini API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP: Gemini API": {
      "main": [
        [
          {
            "node": "Function: Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Function: Parse AI Response": {
      "main": [
        [
          {
            "node": "IF: Has Results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF: Has Results": {
      "main": [
        [],
        [
          {
            "node": "HTTP: Save Forecast",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP: Save Forecast": {
      "main": [
        [
          {
            "node": "Function: Restore Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Function: Restore Data": {
      "main": [
        [
          {
            "node": "IF: High Risk Detected",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "IF: High Risk Detected": {
      "main": [
        [
          {
            "node": "HTTP: Get Task Owner Email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP: Get Task Owner Email": {
      "main": [
        [
          {
            "node": "Function: Prepare Email Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Function: Prepare Email Data": {
      "main": [
        [
          {
            "node": "Send Email: Alert to Owner",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Email: Alert to Owner": {
      "main": [
        [
          {
            "node": "HTTP: Log Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {},
  "versionId": "1",
  "id": "1",
  "meta": {
    "instanceId": "ai_deadline_n8n"
  },
  "tags": []
}